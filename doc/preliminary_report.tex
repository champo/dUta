\documentclass[11pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}

\title{Preliminary Report}
\author{Civile, Juan \and Sneidermanis, Dario \and Kenny, Kevin}
\date{9 de Mayo del 2012}

\begin{document}

\newcommand{\awesome}[1]{\texttt{\large #1}}
\newcommand{\ua}{\textit{User Agent} }
\newcommand{\os}{\textit{Origin Server} }
\newcommand{\duta}{\awesome{dUta}}

\maketitle
\tableofcontents
\clearpage

\section{RFCs consultados}

\begin{itemize}

    \item \awesome{RFC 822}  - Standard for the format of ARPA Internet text messages
    \item \awesome{RFC 2119} - Key words for use in RFCs to Indicate Requirement Levels
    \item \awesome{RFC 2396} - Uniform Resource Identifiers (URI): Generic Syntax
    \item \awesome{RFC 1945} - Hypertext Transfer Protocol -- HTTP/1.0
    \item \awesome{RFC 2068} - Hypertext Transfer Protocol -- HTTP/1.1
    \item \awesome{RFC 2616} - Hypertext Transfer Protocol -- HTTP/1.1
    \item \awesome{RFC 2046} - Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types
    \item \awesome{RFC 2047} - MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text
    \item \awesome{RFC 2324} - Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)
    \item \awesome{RFC 4627} - The application/json Media Type for JavaScript Object Notation (JSON)
    \item \awesome{RFC 2617} - HTTP Authentication: Basic and Digest Access Authentication

\end{itemize}

\section{Diseño de los Protocolos}
Tomamos la sintaxis definida por el RFC 2616 en las secciones 2.1 ``Augmented BNF'' y 2.2 ``Basic Rules''.
Tambien tomamos las definiciones de las secciones 2.5 ``Numbers'' y 2.6 ``Strings'' del RFC 4627.
En caso de definciones conflictivas, se toma con mayor precendecia las definciones del RFC 4627.

El protocolo de configuracion y monitoreo de \duta utiliza el protocolo HTTP 1.1 como transporte.
El proxy presentara un servidor HTTP en un puerto distinto al 80, todavia sin determinar.
La implementacion HTTP sera la misma que la utilizara el proxy para su funcion normal.
Es decir, toda aquella funcionalidad HTTP 1.1 que el servidor proxy no soporte, no sera soportada por el servidor de configuracion.

Los mensajes que recibe y envia este servidor seran con \textit{Content-Type: application/json}, como definido en el RFC 4627.
Mediante el intercambio de mensajes se permitira cambiar la configuracion de \duta en tiempo de ejecucion y obtener metricas del comportamiento del mismo.

Tambien se hara uso de la \textit{Basic Authentication Scheme} definida en el RFC 2617.
El usuario y contraseña utilizados por este mecanismo seran determinados mediante un archivo de configuracion.

Cualquier recurso o mensaje que no este detallado en la siguiente seccion, producira un status code de error correspondiente.

\subsection{Nuevo filtro}
\label{sec:new-filter}
Para configurar nuevos filtros se debe hacer un request \awesome{POST} al recurso \awesome{/filter} con un mensaje del formato \textit{filter}.
De ser agregado correctamente, la respuesta tendra status code 201 y especificara mediante \textit{Location} el recurso asociado al nuevo filtro.
En caso de encontrar un error con el mensaje enviado, se retornara un status code 400, y de ser posible, un mensaje que indique el error.

\begin{verbatim}
filter =
    ("{ 'type': " type ", 'apply': " apply "}") |
    ("{ 'type': " type ", 'apply': " apply ", 'config': " config "}")

type =
    "'deny-all'" |
    "'deny-ip'" |
    "'deny-url'" |
    "'deny-type'" |
    "'deny-size'" |
    "'l33t'" |
    "'rotate'"

apply = "[" apply-rules "]"

apply-rules =
    apply-rule |
    (apply-rule ", " apply-rules)

apply-rule =
    "{ 'host': " host-string "}" |
    "{ 'ua': " string "}"

\end{verbatim}

La definicion de \textit{host-string} es mixta.
Debe respetar las reglas de \textit{string} definidas en el RFC 4627 y contener un valor valido segun el \textit{host} aceptado por el RFC 2616.

El contenido aceptado por \textit{config} y si debe ser omitido o no, es determinado por el valor de \textit{type}.
Los valores \textit{deny-all}, \textit{l33t} y \textit{rotate} no deben incluir \textit{config}.
\subsubsection{deny-ip}
\begin{verbatim}
config = [ host-list ]
host-list = host-string | (host-string ", " host-list)
\end{verbatim}

\subsubsection{deny-url}
\begin{verbatim}
config = [ url-list ]
url-list = uri | (uri ", " url-list)
uri = string
\end{verbatim}

\subsubsection{deny-type}
\begin{verbatim}
config = [ mime-list ]
mime-list = mime | (mime ", " mime-list)
mime = string
\end{verbatim}

\subsubsection{deny-size}
\begin{verbatim}
config = size
size = int
\end{verbatim}

\subsection{Remover filtros}
Para remover un filtro configurado, se debe enviar un request con metodo \textit{DELETE} y mensaje vacio al recurso asociado al filtro.

\subsection{Monitoreo}
Para obtener los valores de monitoreo, existira un recurso por cada posible categoria.
Al enviar un request con metodo \awesome{GET}, el servidor respondara con el valor correspondiente.
Los mensajes contenidos en las respuestas, todos tendran el mismo formato, \textit{value}.
\begin{verbatim}
value = "{ 'value': " int "} "
\end{verbatim}

Los recursos disponibles son:
\begin{itemize}
    \item \textit{/stats/bytes}
    \item \textit{/stats/bytes/clients}
    \item \textit{/stats/bytes/servers}
    \item \textit{/stats/filter/type} --- Donde \textit{type} es es el definido en \ref{sec:new-filter}.
    \item \textit{/stats/channels}
    \item \textit{/stats/channels/clients}
    \item \textit{/stats/channels/servers}
\end{itemize}

\section{Analisis de los RFCs}

\section{Herramientas}
    Durante el desarrollo vamos a utilizar las siguientes herramientas:
    \begin{itemize}
        \item \awesome{JMeter} - Herramienta para benchmarking de aplicaciones
        \item \awesome{Apache Bench} - Herramienta de benchmarking para servidores HTTP
        \item \awesome{nginx} - Servidor HTTP
        \item \awesome{8tracks} - \emph{``Handcrafted internet radio''}
        \item \awesome{curl} - Herramienta de transferencia de datos
        \item \awesome{netcat} - Utilidad para transferencia de datos por TCP y UDP
        \item \awesome{Chromium} - Navegador web
    \end{itemize}

\section{Casos de prueba}
% Con netcat para mandar edge cases del formato de los headers
\subsection{Headers con campos multilinea y con multiples valores}
Usando la herramienta \awesome{netcat}, enviaremos requests que en sus headers contengan casos especiales.
Uno de estos casos es tener un campo multilinea.
El otro es tener multiples instancias de un mismo header, como por ejemplo \textit{Cookie}.

% Con curl para mandar metodos no soportados (TRACE)
\subsection{Requests invalidos}
Compraberemos que el proxy responde con el status code adecuado cuando recibe requests con metodos que no soporta.
Por ejemplo, \awesome{TRACE}.

% Contra un server que sirva archivos grandes
% \subsection{Mensajes grandes}
% TODO: Write something

\subsection{Throughtput}
Para medir la capacidad del proxy, utilizaremos \awesome{JMeter}.
El objetivo es obtener metricas como latencia y requests por segundo para una variedad de escenarios.
Los escenarios tendran variaciones en:
\begin{itemize}
    \item Requests totales
    \item Requests concurrentes
    \item Servidor destino
    \item Filtros y transformaciones aplicadas
\end{itemize}

\subsection{Filtros}
Consideramos como \textit{filtros} a las reglas de control de acceso y transformaciones que puede aplicar el proxy.

\subsubsection{Transfer-Encoding}
Ante una respuesta con \textit{Transfer-Encoding: chunked} un filtro debe correctamente reconstruir el mensaje y luego aplicar la logica que corresponda.

\subsubsection{Cache Headers}
Podria ocurrir que el \os devuelva contenido con \textit{Cache headers} al que se aplica un filtro en el proxy.
Luego, el filtro es desactivado y el \ua vuelve a pedir este contenido con un \awesome{GET} condicional.
Si no se manipularon correctamente los headers de la respuesta original, el \os puede retornar un status code 304, haciendo que el \ua muestre contenido invalido.

\subsubsection{Multipart MIMEs}
El mensaje entregado por un \os puede ser del tipo \textit{multipart/*}.
Este tipo de mensajes puede a su vez contener partes a las que apliquen filtros.
Por lo tanto el proxy tiene que ser capaz de procesar estas partes individualmente y luego entregar un mensaje con todas ellas, sin perdida de informacion.

% Da incluir algo sobre archivos grandes? No se como vamos a manejar esto, asi que me pa que no da.

\end{document}
